> ## 9강 타입변환 <br>

> ### 9.2 문자열 타입으로 변환<br>
>
> " + " 연산자는 피연자 중 하나 이상이 문자열이므로 문자열 연결 연산자로 동작한다. <br>
> 문자열 연결 연산자의 모든 피 연산자는 코드의 문박상 모두 문자열 타입이여야 한다.

```
(ex)
1 + '2' // '12'

// 숫자타입
0 + ''  // '0'
-0 5 + ''  //'0'
1 + ''  //'1'
NaN + ''    //'NaN'

//  불리언 타입
true + ''   //'true'
false + ''  // 'false'
```

> ### 9.2.2 숫자타입으로 변환

- 산술연산자의 역할은 숫자 값을 만드는 것이다.
  따라서 산술 연산자으 모든 피연산산자는 코드 문맥상 모두 숫자 타입이어야 한다.

* 간단히 말해서 문자를 모두 숫자로 인식한다 는 말.!
* 숫자 타입으로 변환할수 없는 경우는 산술 연산을 수행할수 없으므로 표현식의 결과값은 NaN이다.

```
 (ex)
 1 - '1' // 0
 1 * '10' // 10
 1 / 'one' // NaN
```

- 비교연산자의 역할은 불리언 값을 만드는 것이다.
  비교 연산자는 피연산자의 크기를 비교하므로 모든 피연산자는 코드의 문맥상 모두 숫자 타입이어야 한다.

```
'1' > 0 // true
```

```
//문자열타입
+''     // 0
+'0'    //0
+'1'    // 1
+'string'   //NaN

//불리언 타입
+true   // 1
+false  // 0
```

> ### 9.2.3 불리언 타입으로 변환

- if 문이나 for 문과 같은 제어문 또는 삼항 조건 연산자의 조건식은 불리언 값, 즉 참/거짓으로 평가 되어야하는 표현식이다.

```
(ex)
if('') console.log('1'); //거짓
if(true) console.log('2');   // 참
if(0)console.log('3');  // 거짓
if('str') console.log('4'); // 참
if(null) console.log('5');  // 거짓

// 2  4  출력
```

> ### 9.3 명시적 타입 변환

> ### 9.3.1 문자열 타입 변환

- String 생성자 함수를 new연산자 없이 호출하는 방법
- objct.prototype.toString 메서드를 사용하는 방법
- 문자열 연결 연산자를 이용하는 방법

```
// object.prototype.toString 메서드를 사용하는 방법

-//숫자타입 => 문자열타입
(1).toString    // "1"
(NaN).toString  // "NaN"

-// 블리언 타입 => 문자열 타입
(true).toString();  // "true"
(false).toString(); // "false"
```

> ### 9.3.2 숫자 타입 변환

- 숫자 타입이 아닌 값을 숫자 타입으로 변환하는 방법

---

- Number 생성자 함수를 new 연산자 없이 호출하는 방법
- parseInt, parseFloat 함수를 사용하는 방법
- +단항 산술연산자를 이용하는 방법
- \*산술 연산자를 이용하는 방법

```
1. Number 생성자 함수를 new연산자 없이 호출하는 방법
// 문자열 타입 => 숫자 타입
Number('0');    // 0
Number('-1');   // -1

// 블리언 타입 => 숫자 타입
Number(true);   // 1
Number(false);  // 0

2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)
// 문자열타입 => 숫자 타입
parseInt('0');  // 0
parseInt('-1'); // -1
parseFloat('10.53');    // 10.53
```

> ### 9.3.3 불리언 타입 변환

- 불리언 타입이 아닌 값을 불리언 타입으로 변환하는 방법

---

- Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
- ! 부정 논리 연산자를 두번 사용하는 방법

```
// 1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
// 문자열 타입 => 불리언 타입

Boolean('x');   //true
Boolean('');    //false
Boolean('false');   //true

// 숫자 타입 => 불리언 타입
Boolean(0); //false
Boolean(1); // true
Boolean(NaN);   // false

// null 타입 => 블리언 타입
Boolean(null);  // true

//2. ! 부정 논리 연산자를 두 번 사용하는 방법
// 문자열 타입 => 불리언 타입
!!'x';  // true
!!'';   // false
!!'false';  // true

// 숫자 타입 => 불리언 타입
!!0;    // false
!!1;    // true
!!NaN;  // false

!!undefined;    // false
```

> ### 9.4.1 논리 연산자를 사용한 단축평가

- 논리합(||) 또는 논리곱(&&) 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.

- ## && (논리곱)

```
'Cat' && 'Dog'  // 'Dog
```

--> 논리곱(&&) 연산자는 두 개의 피연산자가 모두 true로 평가될때 true를 반환한다.<br>
--> 논리곱 연산자는 논리 연산의 결과를 결정하는 두 번째 피연자, 즉 문자열 'Dog'를 그대로 반환한다.

- ## || (논리합)

```
'Cat' || 'Dog'  // 'Dog'
```

--> 논리합(||) 연산자는 두 개의 피연산중 하나만 true로 평가되어도 true를 반환한다.
--> 둘중 하나만 true여도 true이므로 첫번쨰 연산자
'Cat'가 true이므로 다른것은 평가하지 않는다.
그래서 복잡한 피연산자는 뒤에 두는게 낫다.

```
// 논리합(||)연산자
'Cat' || 'Dog'  // 'Cat'
'false || 'Dog' // 'Dog'
'Cat' || flase  // 'Cat'

// 논리곱(&&) 연산자
'Cat' && 'Dog'  // 'Dog'
false && 'Dog'  // false
'Cat' && false  // false
```
